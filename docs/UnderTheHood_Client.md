## Under the hood
I will give you a short introduction into the internals of Typedapi and how it uses type-level computation to derive HTTP clients and servers.

**Note** When reading this document you have to keep in mind that Typedapi was created with the idea in mind to move most of the computations on the type-level.

### API Definition
You can define APIs by using the known dsl:

```Scala
val Api = := :> "user" :> Segment[String]('name) :> Get[User]
```

What's happening here is that Typedapi creates a `FinalCons[H]` with `H <: shapeless.HList` representing the given API. 
When you inspect the `H` for the given example it will look like the following:

```Scala
val findW = Witness("find")
val nameW = Witness('name)

type H = GetElement[User] :: SegmentParam[nameW.T, String] :: PathElement[findW.T] :: HNil
```

`FinalCons` itself doesn't store any value. It is just a carrier (helper value) for `H` as we are not able to work directly with types as we do with values in Scala.

#### How does it work?
When calling `:=` you create an empty API type carrier. Everytime you use `:>` you add a new element to the type. The actual values you supply are just there to overcome the limitations of Scala, e.g. we cannot simply define a singleton type from a String on the type-level like this `type findW = "find"`. We have to create a singleton typed value (Witness) from that literal and extract the type.

### API Transformation
After we moved the API to the type-level we need to extract the expected input which we can use later to determine the client functions. We do that by transforming `H <: HList` to a type triple `(El <: HList, In <: HList, A)` with:
  - `El`, API elements
  - `In`, expected input
  - `A`, expected output
  
For our example this will look like the following:
  
```Scala
type El = findW.T :: SegmentInput :: GetCall :: HNil
type In = FieldType[nameW.T, String] :: HNil
type A  = User
```

`El` doesn't carry type information anylonger about input or output types. It just defines what elements are within the API. On the otherhand, `In` describes the input types and their names without caring about the actual API elements.

#### How does it work?
The type-class `ApiTransformer` walks through the API and maps every element to `El` and `In` if it is an input element. To do so Typedapi implements `TypelevelFoldLeft` which does the same as the usual `foldLeft` of `List` structures but operates solely on a `HList` type. No instance is given. What happens is, that Typedapi folds `H` and thereby creates the type triple `(El, In, A)`.

All the steps we saw till now are similar for the client and server side. This is not true for the following parts and that is why we will distingiush the two from now on.

## Client side
### API Compiler to generate request data
The last step generates a function `In => RequestData[R, D <: HList]` which gets all expected inputs as defined by `In` and maps them to `type RequestData[R, D <: HList] = FieldType[R, D] :: HNil`. Here `R` represents the method and `D` is a `HList` composed of:
  - uri (`List[String]`)
  - query (`Map[String, List[String]]`)
  - header (`Map[String, String]`)
  - optional request body (`Bd`)

This function is generated by the type-class `ApiCompiler` which takes the type triple from the previous stage and builds a nested function call structure from `El`, `In` and `A`. For our example the function type would look like this:

```Scala
FieldType[nameW.T, String] :: HNil => RequestData[FieldType[GetCall, List[String] :: Map[String, List[String]], Map[String, String]]]
```

### Execute a request
After creating a function to generate request data we can come to the last step, actually executing a request. This is done by the `ApiRequest` implementations provided by the different HTTP frameworks like *http4s* or *akka-http*. You can find some suport code in the `TypedApi` object that does some lifting to combine `ApiCompiler` functions with `ApiRequest`.

### Api Compiler Ops
We could already use the above code to execute requests but it would be quite verbose and unintuitive as you have to provide in input of type `In`. Or in other words, you have to build a `HList` and pass it as parameter. To get a more function-call-like behaviour Typedapi provides `ApiCompilerOps` (implicit extension classes) which map inputs of size `n` to functions of arity `n`:

```
type In = A :: B :: C :: HNil // size 3

type Fun3 = (A, B, C) => A // arity 3
```

What these instances are doing is adding an `apply` function to a `ApiCompiler` instance (our request data generating function) which expects exactly as many input parameters as `In` defines, in the same order, and with the same types.

<... will be continued>
